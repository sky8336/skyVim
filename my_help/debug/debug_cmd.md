# debug command
linux 设备驱动调试技术
- Maintainer: sky8336
-    Created: 2018-08-11
- LastChange: 2019-11-07
-    Version: V0.0.07
============================================================
一、通过打印调试
printk
cat /proc/sys/kernel/printk
echo 8 > /proc/sys/kernel/printk

串口控制台
============================================================
二、通过查询调试
在需要时查询系统信息。

------------------------------------------------------------
每个unix系统都提供了许多工具，用于获取系统信息:
ps、top、netstat、vmstat、uptime

linux 系统监控、诊断工具top
	-- 监控系统实时负载率、进程的资源占用率及其它各项系统状态
	属性是否正常。

	top -d 3 -n 10

系统慢，看有哪些进程在运行:
	进入adb shell查看是否有工作队列等在运行，kworker.
	adb shell 中:
	top -d 3 -m 10
	--显示10个

------------
pidof 是Linux系统中用来查找正在运行进程的进程号（pid)的工具
pidof bash | wc -w

------------
busybox
adb shell中:
	busybox linux命令

------------------------------------------------------------
两种主要的技术:
	(1)在/proc 文件系统中创建文件。
		--/proc方式的另一个选择是使用devfs
	(2)使用驱动程序的 ioctl 方法。

--------------------
(1)使用/proc文件系统
	是一种特殊的、由程序创建的文件系统，内核使用它向外界输出信息。
	/proc 下面的每个文件都绑定于一个内核函数，这个函数在文件被读取时，
动态地生成文件的“内容”。

	<1> 列出当前载入模块的列表
		/proc/modules

	<2> 查看中断
		cat /proc/interrupts | grep RES
		调试时，进入adb shell,重复执行,查看是否有中断

	<3> 查看内核打印信息
		cat /proc/kmsg | grep key

		dmesg

------------
(2)ioctl方法
	ioctl是作用于文件描述符之上的一个系统调用,需要另一个程序调用
ioctl 并显示结果。


============================================================
三、通过监视调试
	监视用户空间中应用程序的运行情况,可以用调试器一步步跟踪它
的函数，插入打印语句，或者在 strace 状态下运行程序。

strace 命令(可在adb shell中运行)

	显示程序所调用的所有系统调用,还能显示调用参数，以及用符号
方式表示的返回值.当系统调用失败时，错误的符号值（如 ENOMEM）和
对应的字符串（如Out of memory）都能被显示出来。

	strace ls /dev > /dev/scull0

strace 有许多命令行选项(最为有用的是):
	-t，用来显示调用发生的时间；
	-T，显示调用所花费的时间；
	-e，限定被跟踪的调用类型；
	-o，将输出重定向到一个文件中。

	<1> strace 默认将跟踪信息打印到 stderr 上。
	<2> trace从内核中接收信息。一个程序无论是否按调试方式编译
（用 gcc 的-g选项）或是被去掉了符号信息都可以被跟踪。
	<3> strace 可以跟踪一个正在运行的进程。
	<4> 驱动程序通过响应系统调用得到执行；strace 允许我们检查每次
调用中输入和输出数据的一致性。

============================================================
四、调试系统故障
	获取尽可能多的信息对解决问题是至关重要的。

<1> 故障通常会导致当前进程崩溃，而系统仍会继续运行。
<2> 如果在进程上下文之外发生故障，或是系统的重要组成被损害时，
	系统才有可能 panic。
	如果问题出在驱动程序中时，通常只会导致正在使用驱动程序的
	那个进程突然终止。
<3> 唯一不可恢复的损失就是进程被终止时，为进程上下文分配的一
	些内存可能会丢失。
<4> 由于内核在进程中止时会对已打开的设备调用 close 操作，驱动
	程序仍可以释放由 open 方法分配的资源。

当内核行为异常时，会在控制台上打印出提示信息,处理器在出错时转
储出的这些数据包含了许多值得关注的信息，通常足以查明程序错误，
而无需额外的测试。

------------------------------------------------------------
(1) oops消息
大部分错误都在于 NULL指针的使用或其他不正确的指针值的使用上。

当引用一个非法指针时，页面映射机制就不能将地址映射到物理地址，
此时处理器就会向操作系统发出一个“页面失效”的信号。
如果地址非法，内核就无法“换页”到并不存在的地址上；如果此时处理
器处于超级用户模式，系统就会产生一个“oops”

oops 显示发生错误时处理器的状态:
	<1> CPU 寄存器的内容、
	<2> 页描述符表的位置、
	<3> 其它看上去无法理解的信息。

	这些消息由失效处理函数（arch/*/kernel/traps.c）中的 printk
语句产生。

最为相关的信息是: 指令指针（EIP），即出错指令的地址。


两个解析工具：
	<1> klogd
	<2> ksymoops

---------
<1> klogd
klogd 守护进程能在 oops 消息到达记录文件之前对它们解码。
只要运行就会自行进行符号解码。

klogd 在开始运行时装入所有可用符号，并随后使用这些符号。
如果在 klogd 已经对自身初始化之后（一般在系统启动时），
装载某个模块，klogd 将不会有这个模块的符号信息。

必须提供符号表文件System.map的一个当前复本，通常在/boot中。

------------
<2> ksymoops
需要用户有目的地调用

使用命令行选项告诉它在什么地方能找到需要的信息。
最好在引起 oops 发生之前，保存/proc/modules 和/proc/ksyms 的复本。

想查看发生故障的完整函数:
	objdump -d xxx.o

------------------------------------------------------------
(2)系统挂起
处理系统挂起有两个选择:
	<1> 防范于未然；
	<2> 亡羊补牢，在发生挂起后调试代码。

在一些关键点上插入 schedule 调用可以防止死循环,不知该在什么
位置插入 schedule 调用时，最好的方法是加入一些打印信息，并把
它们写入控制台。

一定不要在驱动程序持有spinlock 的任何时候调用 schedule。

辨别假挂起：
	显示器上的时钟或系统负荷表(很好的状态监视器)只要保持更新，
说明scheduler 正在工作。

	如果没有使用图形显示，则可以运行一个程序让键盘LED闪烁等来
检查scheduler 是否工作正常。

============================================================
五、调试器和相关工具
使用调试器来一步步地跟踪代码，查看变量和计算机寄存器的值。
非常耗时，应该尽量避免。

------------------------------------------------------------
(1)使用 gdb
在探究系统内部行为时非常有用。
需要掌握 gdb 命令、了解目标平台的汇编代码，具备对源代码和优化
后的汇编码进行匹配的能力。

把内核看作是一个应用程序。

指定未压缩的内核映像文件名,在命令行中提供“core 文件”的名称
(这个内核在内存中的核心映像 /proc/kcore)

典型的 gdb 调用：
	gdb /usr/src/linux/vmlinux /proc/kcore

对内核进行调试时，gdb 通常能提供的许多功能都不可用。
例如，gdb 不能修改内核数据；
因为在处理其内存映像之前，gdb 期望把待调试程序运行在自己的控制之下。
也不能设置断点或观察点，或者单步跟踪内核函数。

当目的在于查看内核的运行情况时，gdb是一个有用的工具，但对于
设备驱动程序的调试，它还缺少一些至关重要的功能。

------------------------------------------------------------
(2) kdb 内核调试器
在 oss.sgi.com 上以非正式的补丁形式提供

------------------------------------------------------------
(3)集成的内核调试器补丁
IKD（integrated kernel debugger）

内核堆栈调试
发现内核死锁的工具
内核的跟踪功能
内存调试工具,跟踪内存崩溃问题

------------------------------------------------------------
(4)kgdb 补丁
从 oss.sgi.com 获得
提供完整的 gdb 调试器功能,仅限于 x86 系统
通过串口连线以钩子的形式挂入目标调试系统进行工作，在远端运行gdb

------------------------------------------------------------
(5)内核崩溃转储分析器
使系统能把发生 oops 时的系统状态记录下来
对于一个异地用户的驱动程序进行支持，特别有用

第一个分析器是 LKCD（Linux Kernel Crash Dumps,“Linux内核崩溃转储”）。
从 oss.sgi.com 上获得。

另一个崩溃转储设施可以从 www.missioncriticallinux.com 获得。
这个崩溃转储子系统直接在目录 /var/dumps 中创建崩溃转储文件，
并不使用交换区。

------------------------------------------------------------
(6)用户模式的 Linux 虚拟机
作为一个独立的可移植的Linux内核而构建，包含在子目录arch/um中,
运行在基于Linux 系统调用接口所实现的虚拟机之上。

用户模式 Linux 可以使 Linux 内核成为一个运行在 Linux 系统之上
单独的、用户模式的进程。以很容易地利用 gdb 或其它调试器对用户
模式 Linux 进行处理。

------------------------------------------------------------
(7) Linux 跟踪工具包
包含了一组可以用于内核事件跟踪的相关工具集
在 Web 站点 www.opersys.com/LTT 上，可以找到 LTT 以及大量的资料。

------------------------------------------------------------
(8) Dynamic Probes
IBM 为基于 IA-32 结构的Linux 发布的一种调试工具

它可以在系统的几乎任何一个地方放置一个“探针”
一旦内核编译进了这个功能，探针就可以插到一个运行系统的任一个
位置，而无需重建内核或重新启动。

============================================================
工具:
串口控制台

objdump
反汇编模块函数,只能对磁盘上的文件复本进行处理,不能对运行中的模块进行处理
--参阅objdump手册页

============================================================
Unable to read /proc/kallsyms...
That's because your system may be preventing the program from reading kernel
symbols in /proc/kallsyms due to /proc/sys/kernel/kptr_restrict set to 1. The
following command will do the tricky:
	sudo sh -c " echo 0 > /proc/sys/kernel/kptr_restrict"
before run this command, the addr in kallsyms is zero.
--------------------------------------------------------------------------------
yocto linux 插入usb后，dmesg,看到新增sda1
ls /dev/sda1 节点出现。
mount usb 设备：
mkdir /tmp/sda
mount -t ntfs /dev/sda1 /tmp/sda

拔出前， umount
cd 出usb中的目录
umount /tmp/sda


--------------------------------------------------------------------------------
linux version
cat /proc/version
uname -a
--------------------------------------------------------------------------------
$ cat /proc/cmdline 
BOOT_IMAGE=/boot/vmlinuz-4.4.0-109-generic root=UUID=ae3e2a39-4213-4d87-b823-5d20bdd81b88 ro quiet splash vt.handoff=7
